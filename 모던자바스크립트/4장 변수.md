변수(varaible)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

프로그래밍언어(여기선 js)는 기억하고 싶은  값을 메모리에 저장하고, 저장된 값을 읽어 들여 재사
용하기 위해 변수라는 메커니즘을 제공한다.


### 식별자

그림 A
![[Screenshot_20240527-185412.png|400]]

```js title:"코드블럭 A"
var result = 10 + 20;
console.log(result);
```

코드블럭A에서 result라는 변수는 10 + 20 의 결과값인 30의 값을 가지고 있는 메모리 주소와 매핑 되어 메모리 주소를 기억하고, 그 메모리안의 값인 30의 값을 접근할 수 있는 것이다. 
==즉, 변수 result는 30의 값을 가지고 있는 것이 아니라 30을 저장하고 있는 메모리 주소를 기억하고 있는 것이다.==

### 변수 선언
변수 선언이란 변수를 생성하는 것을 말한다.
변수를 선언할 때는 ==var, let, const== 키워드를 사용한다.

자바스크립트 엔진은 변수선언을 2단계에 거쳐 수행한다.
1. 선언단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

```js title:"코드블럭B"
var score;
console.log(score);
```

var키워드를 사용한 변수 선언은 선언단계와 초기화 단계가 동시에 진행된다. 
score라는 변수 이름을 등록하고, 초기화 단계를 통해 score변수에 암묵적으로 undefiend를 할당해 초기화한다. 

여기서 ==초기화란, 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다.== var키워드로 선언한 변수는 어떠한 값도 할당하지 않아도 undefined라는 값을 갖는다.(코드블럭B 참고)

만약, 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아 있을 수 있다. 예를들어, 변수 score를 선언하고 score변수에 메모리(0x000000F2)공간을 부여한다면 score변수는 값을 할당하지 않았음에도 불구하고, 선언과 동시에 10이라는 값을 가지게 된다. (그림 A참고)

그림 A를 보면 10+20의 연산이후에 20의 값을 가지고 있는 메모리공간은 어떠한 쓰임도 있지 않다.
이렇게 쓸모가 없음에도 메모리공간을 차지하고 있는 값을 쓰레기 값(garbage value)이라 한다.

### 변수 선언의 실행 시점과 변수 호이스팅

```js title:"코드블록 C"
console.log(example);
```
```js title:"코드블록 D"
console.log(score);
var score;
```

```js 코드블록E title:"코드블록 E"
var score;
console.log(score);
```
자바스크립트는 [[인터프리터]]언어로 한 줄씩 순차적으로 실행된다.
만약, 코드블록 D를 실행한다면 변수 선언전에 바로 변수를 읽어들이는 console.log(score);가 실행되기 때문에 에러가 뜰 것이라고 추측할 수 있다. 하지만! 실제로 실행하면 1번행은 잘 실행되고 그 값은 undefined라는 값이 나오게 된다. 

그 이유는 **변수 선언이 소스코드가 한 줄씩 순차적으로 실행되는 시점. 즉 런타임이 아니라 그 이전 단계에서 먼저 실행되기 때문이다.**

자바스크립트 엔진은 소스코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 [[소스코드의 평가 과정]]을 거치면서 소스코드를 실행하기 위한 준비를 한다. 이때 자바스크립트 엔진은 변수선언을 포함한 모든 선언문을 소스코드에서 찾아내 먼저 실행한다. ==즉! 코드블록 D를 실행하면 1번행 부터 실행하는 것이 당연하지만 그전에 평가 과정에 의해서 실질적으로는 코드블록 E처럼 동작하는 것으로 생각하면 된다.==

이처럼 **변수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅(variable hoisting)이라 한다.**
- var, let, const, function, function*, class 키워드를 사용해서 선언하는 모든 식별자는 호이스팅 된다.

### 값의 할당

```js title:"코드블록 F"
var score; //변수선언
score = 80; //값의 할당

var score = 80; //변수 선언과 값의 할당
```

자바스크립트는 코드블록 F의 4번행처럼 변수선언과 값의 할당을 동시에 하나의 문의로 ==표현==할 수 있다. 즉! 표현만 하는 것이지 실질적으로는 4번행을 실행해도 변수선언과 값의 할당을 1번행과 2번행처럼 나누어 각각 실행한다.

여기서 ==주의할 점은 변수선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전, 소스코드의 평가과정에서 먼저 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 런타임에 실행된다.==

```js title:"코드블록 G"
console.log(score);

var score = 80;   // 1. var score; 
                  //2. score = 80; 두단계로 나눠서 진행

console.log(score);
```

위의 내용을 이해하고 코드블록 G를 보면 1행은 undefined가 나올 것이라는 것을 예상할 수 있고, 
5행은 80이 나올 것이라고 예상할 수 있다.  이유는 자바스크립트 엔진의 소스코드 평가과정과 런타임 시점을 적용하면 실직적으로는 코드블록 H처럼 실행된다고 생각 할 수 있다.(그림 B참고)

```js title:"코드블록 H"
var score;
console.log(score);
score = 80;
console.log(score);
```

그림B
//사진넣기


그림B 에서 주의할 점은 변수에 값을 할당할 때는 이전 값 undefined가 저장되어 있던 메모리 공간을 지우고 그 메모리 공간에 할당값 80을 새롭게 저장하는 것이 아니라 새로운 메모리 공간을 확보하고 그곳에 할당 값 80을 저장한다는 점에 주의하자.

### 값의 재할당 

```js title:"코드블록 I"
var score = 80;
score = 90;
```

그림 C
//그림넣기


var 키워드로 선언한 변수는 값을 재할당할 수 있다. 재할당은 현재 변수에 저장된 값을 버리고 새로운 값을 저장하는 것이다.

그림 C를 보면 undefined와 80은 더이상 필요하지 않다. 따라서 이러한 불필요한 값들은 [[가비지콜렉터]]에 의해 메모리에서 자동해제 된다. 단, 메모리에서 언제 해제될지는 예측할 수 없다.